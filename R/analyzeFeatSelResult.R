#' @title Shows the detailed steps of the feature selection.
#'
#' @description
#' This function prints the steps \code{\link{selectFeatures}} took to find it's optimal set of features and the reason why it stopped.
#' It can also give information about all calculations done on each intermediate step.
#'
#' @param fs.obj [\code{FeatSelResult(1)}]\cr
#'   The result of one feature selection generated by \code{\link{selectFeatures}}.
#' @param reduce [\code{logical(1)}]\cr
#'   \code{TRUE} if the results of all calculations for each step should be printed. \cr
#'   \code{FALSE} only the calculation leading to the improving feature set is printed. \cr
#'   Default is \code{FALSE}.
#' @return Nothing.
#' @export
analyzeFeatSelResult = function(fs.obj, reduce=TRUE){
  cl = class(fs.obj$control)[1L]
  stopifnot(cl %in% c("FeatSelControlSequential", "FeatSelControlGA"))
  analyzeFunc = switch(cl,
    FeatSelControlSequential = analyzeSequential,
    FeatSelControlGA = analyzeGA,
    stop(paste("Unknown class of control object:", cl)))
  analyzeFunc(fs.obj, reduce)
}


analyzeSequential = function(fs.obj, reduce=TRUE){
  df = as.data.frame(fs.obj$opt.path)
  feat.names = names(fs.obj$opt.path$par.set$pars)
  measure = fs.obj$opt.path$minimize[1L]
  optimum = ifelse(measure, min(df[,names(measure)]), max(df[,names(measure)]))
  df$optimum = (df[,names(measure)] == optimum)
  df$selected = (is.na(df$eol) | (df$dob < df$eol))
  df$n.feats = rowSums(df[,feat.names])
  if(reduce)
    df = df[(df$optimum | df$selected), ]
  ctrl = fs.obj$control
  result = list(reduced.data.frame = df, control = ctrl, x = fs.obj$x, y = fs.obj$y, features = feat.names)
  mode(result) = "list"
  class(result) = "analyzeFeatSelResult"
  return(result)
}

stringMaxConcat = function(x, printed.features){
  l = length(x)
  x = head(x, printed.features)
  if(l > printed.features)
    x = c(x, "etc.")
  collapse(clipString(x, 20L), ", ")
}

printAnalyzeFeatSelResultHead = function(x, printed.features=10L){
  catf("FeatSel result:")
  catf("- Features         : %i", length(x$x))
  catf("- Performance      : %s", perfsToString(x$y))
  cat("  "); catf(stringMaxConcat(x$x, printed.features))
  catf("\nPath to optimum:")
}

printAnalyzeFeatSelResultSeq = function(x, printed.features=10L) {
  printAnalyzeFeatSelResultHead(x, printed.features)
  df = x$reduced.data.frame
  df$step = as.numeric(as.factor(df$dob))
  # Initialize first Values
  n.feats.old = df[1L,"n.feats"]
  stepVars.old = x$features[df[1L,x$features]==1]
  measures.old = as.numeric(df[1L,names(x$y)])
  names(measures.old) = names(x$y)
  # Iterate over all steps:
  for(i in unique(df$step)){
    df.step = df[df$step==i,]
    # Print what happens in each step
    for(j in seq_row(df.step)) {
      measures = as.numeric(df.step[j,names(x$y)])
      names(measures) = names(x$y)
      measures.gain = measures - measures.old
      n.feats = df.step[j, "n.feats"]
      if (n.feats < n.feats.old) changeTxt = "Removed: "
      else if (n.feats > n.feats.old) changeTxt = "Added: "
      else changeTxt = "Init"
      stepVars = x$features[df.step[j,x$features]==1]
      diffVar = setdiff(union(stepVars, stepVars.old), intersect(stepVars, stepVars.old))
      diffVar = paste(diffVar, collapse=",")
      if (df.step[j,"selected"]) {
        n.feats.opt = n.feats
        stepVars.opt = stepVars
        measures.opt = measures
        txtSelected = TRUE
      } else
        txtSelected = FALSE
      catf("- Features: %4i  \t %-10s%-20s \t Perf = %.4g \t Gain: %.3g \t Sel = %-5s \t Opt = %-5s",
           n.feats, changeTxt, diffVar, measures.opt, measures.gain, txtSelected, any(df.step$optimum))
    }
    # Print end result of each Step
    # catf("Finished step: %i with perf %.3g, Optimum = %s",
         # head(df.step[,"step"],1L), measures.opt,
    n.feats.old = n.feats.opt
    stepVars.old = stepVars.opt
    measures.old = measures.opt
  }

  if (!is.na(x$control$max.features) & (max(df$n.feats) == x$control$max.features)) {
    catf("\nStopped due to reached maximum of allowed features (%i).", x$control$max.features)
  } else {
    catf("\nStopped, because no improving set of features (w.r.t. %s) was found.",
         paste(names(x$y), collapse = ", "))
  }
}

#' @S3method print analyzeFeatSelResult
print.analyzeFeatSelResult = function(x, ...) {
  cl = class(x$control)[1L]
  switch(cl,
    FeatSelControlSequential = printAnalyzeFeatSelResultSeq(x, ...)
    stopf("Not implemented for class %s!", cl)
  )
}
