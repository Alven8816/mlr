#' @title Shows the detailed steps of the feature selection.
#'
#' @description
#' This function prints the steps \code{\link{selectFeatures}} took to find it's optimal set of features and the reason why it stopped.
#' It can also give information about all calculations done on each intermediate step.
#'
#' @param fs.obj [\code{FeatSelResult(1)}]\cr
#'   The result of one feature selection generated by \code{\link{selectFeatures}}.
#' @param reduce [\code{logical(1)}]\cr
#'   \code{TRUE} if the results of all calculations for each step should be printed. \cr
#'   \code{FALSE} only the calculation leading to the improving feature set is printed. \cr
#'   Default is \code{FALSE}.
#' @return Nothing.
#' @export
analyzeFeatSelResult = function(fs.obj, reduce=TRUE){
  cl = class(fs.obj$control)[1L]
  stopifnot(cl %in% c("FeatSelControlSequential", "FeatSelControlGA"))
  analyzeFunc = switch(cl,
    FeatSelControlSequential = analyzeSequential,
    FeatSelControlGA = analyzeGA,
    stop(paste("Unknown class of control object:", cl)))
  analyzeFunc(fs.obj, reduce)
}


analyzeSequential = function(fs.obj, reduce=TRUE){
  df = as.data.frame(fs.obj$opt.path)
  feat.names = names(fs.obj$opt.path$par.set$pars)
  measure = fs.obj$opt.path$minimize[1L]
  optimum = ifelse(measure, min(df[,names(measure)]), max(df[,names(measure)]))
  df$optimum = (df[,names(measure)] == optimum)
  df$selected = (is.na(df$eol) | (df$dob < df$eol))
  df$n.feats = rowSums(df[,feat.names])
  if(reduce)
    df = df[(df$optimum | df$selected), ]
  ctrl = fs.obj$control
  result = list(reduced.data.frame = df, control = ctrl, x = fs.obj$x, y = fs.obj$y, features = feat.names)
  mode(result) = "list"
  class(result) = "analyzeFeatSelResult"
  return(result)
}


analyzeGA = function(fs.obj, reduce=TRUE){
  analyzeSequential(fs.obj, reduce)
}

stringMaxConcat = function(x, printed.features){
  l = length(x)
  x = head(x, printed.features)
  if(l > printed.features)
    x = c(x, "etc.")
  collapse(clipString(x, 20L), ", ")
}

printAnalyzeFeatSelResultHead = function(x, printed.features=10L){
  catf("FeatSel result:")
  catf("- Features         : %i", length(x$x)) 
  catf("- Performance      : %s", perfsToString(x$y))
  cat("  "); catf(stringMaxConcat(x$x, printed.features))
  catf("\nPath to optimum:")
}

printAnalyzeFeatSelResultSeq = function(x, printed.features=10L) {
  printAnalyzeFeatSelResultHead(x, printed.features)
  df = x$reduced.data.frame
  df$step = as.numeric(as.factor(df$dob))
  # Initialize first Values
  n.feats.old = df[1L,"n.feats"]
  stepVars.old = x$features[df[1L,x$features]==1]
  measures.old = as.numeric(df[1L,names(x$y)])
  names(measures.old) = names(x$y)
  # Iterate over all steps:
  for(i in unique(df$step)){
    df.step = df[df$step==i,]
    # Print what happens in each step
    for(j in seq_row(df.step)) {
      measures = as.numeric(df.step[j,names(x$y)])
      names(measures) = names(x$y)
      measures.gain = measures - measures.old
      n.feats = df.step[j, "n.feats"]
      if (n.feats < n.feats.old) changeTxt = "Removed: "
      else if (n.feats > n.feats.old) changeTxt = "Added: "
      else changeTxt = "Init"
      stepVars = x$features[df.step[j,x$features]==1]
      diffVar = setdiff(union(stepVars, stepVars.old), intersect(stepVars, stepVars.old))
      diffVar = paste(diffVar, collapse=",")
      if (df.step[j,"selected"]) {
        n.feats.opt = n.feats
        stepVars.opt = stepVars
        measures.opt = measures
        txtSelected = TRUE
      } else
        txtSelected = FALSE
      catf("- Features: %4i  \t %-10s%-20s \t Perf = %.4g \t Gain: %.3g \t Sel = %-5s \t Opt = %-5s",
           n.feats, changeTxt, diffVar, measures.opt, measures.gain, txtSelected, any(df.step$optimum))
    }
    # Print end result of each Step
    # catf("Finished step: %i with perf %.3g, Optimum = %s",
         # head(df.step[,"step"],1L), measures.opt,
    n.feats.old = n.feats.opt
    stepVars.old = stepVars.opt
    measures.old = measures.opt
  }

  if (!is.na(x$control$max.features) & (max(df$n.feats) == x$control$max.features)) {
    catf("\nStopped due to reached maximum of allowed features (%i).", x$control$max.features)
  } else {
    catf("\nStopped, because no improving set of features (w.r.t. %s) was found.",
         paste(names(x$y), collapse = ", "))
  }
}

printAnalyzeFeatSelResultGA = function(x, printed.features=10L) {
  printAnalyzeFeatSelResultHead(x, printed.features)
  df = x$reduced.data.frame
  generations = 0:x$control$maxit
  for (i in generations) {
    df.this.gen = df[df$dob == i,]
    cat(if (i == 0L) "Initial generation:" else paste0("Generation ", i, ":"))
    if (nrow(df.this.gen) == 0L) {
      catf("- none of the new individuals is better than any from the current best population")
      next
    }
    for (j in seq_row(df.this.gen)) {
      feats = x$features[df.this.gen[j, x$features]==1]
      measures = as.numeric(df.this.gen[j,names(x$y)])
      names(measures) = names(x$y)
      dieTxt = if (!df.this.gen[j, "selected"]) "\t (died out)" else ""
      catf("- (%i) \t Features: %i  \t %s \t Features: %s %s",
           j, df.this.gen[j,"n.feats"], perfsToString(measures), stringMaxConcat(feats, printed.features), dieTxt)
    }
  }
}

printAnalyzeFeatSelResultGA.old = function(x, printed.features=10L) {
  generations = seq_len(x$control$maxit)
  ind_counter = 0L
  ind_act = seq_row(df)
  perf_pop = numeric()
  ## initial generation
  X.init = df[df$dob == 0L, ]
  catf("Initial generation:")
  for(i in seq_row(X.init)) {
    ind_counter = ind_counter + 1L
    meas = X.init[i, m.names]
    names(meas) = m.names
    perf_pop = c(perf_pop, as.numeric(meas))
    if(X.init$n.feats[i] == 0L) {
      catf("  (%02i) select 0 features", ind_counter)
      catf("       performance: %s", perfsToString(meas))
      next
    }
    feats = feat.names[as.logical(X.init[i, feat.names])]
    if(X.init$n.feats[i] == 1) {
      catf("  (%02i) select feature %s:", ind_counter, feats)
      catf("       performance: %s", perfsToString(meas))
      next
    }
    nf = length(feats)
    if(nf > printed.features) {
      catf("  (%02i) select %02i features: %s", ind_counter, nf,
           paste(c(feats[1:printed.features], "..."), collapse = ", "))
    } else {
      catf("  (%02i) select %02i features: %s", ind_counter, nf,
           paste(feats[1:nf], collapse = ", "))
    }
    catf("       performance: %s", perfsToString(meas))
  }
  ## Evaluate the generations (which of the new individuals replaces which of the old ones?)
  for(g in generations) {
    catf("Generation %i:", g)
    X.gen = df[df$dob == g, ]
    new_inds = nrow(X.gen)
    if(new_inds == 0L) {
      catf("- none of the new individuals is better than any from the current best population")
      next
    }
    replace_index = rev(order(perf_pop))[1:new_inds]
    to_be_replaced = ind_act[replace_index]
    if(length(replace_index) == 1L) {
      catf("- replace individual %s with:", paste(paste("(", to_be_replaced, ")", sep = ""), collapse = ", "))
    } else {
      catf("- replace individuals %s with:", paste(paste("(", to_be_replaced, ")", sep = ""), collapse = ", "))
    }
    ## run through the new (better) individuals
    for(k in 1:new_inds) {
      X.sel = X.gen[k, ]
      ind_counter = ind_counter + 1
      ind_act[replace_index[k]] = ind_counter
      meas = X.sel[, m.names]
      names(meas) = m.names
      perf_pop[replace_index[k]] = as.numeric(meas)
      if(X.sel$n.feats == 0L) {
        catf("  (%02i) select 0 features", ind_counter)
        catf("       performance: %s", perfsToString(meas))
        next
      }
      feats = feat.names[as.logical(X.sel[, feat.names])]
      if(X.init$n.feats[i] == 1) {
        catf("  (%02i) select feature %s:", ind_counter, feats)
        catf("       performance: %s", perfsToString(meas))
        next
      }
      nf = length(feats)
      if(nf > printed.features) {
        catf("  (%02i) select %02i features: %s", ind_counter, nf,
             paste(c(feats[1:printed.features], "..."), collapse = ", "))
      } else {
        catf("  (%02i) select %02i features: %s", ind_counter, nf,
             paste(feats[1:nf], collapse = ", "))
      }
      catf("       performance: %s", perfsToString(meas))
    } ## end of loop of individuals per generation
  } ## end of generations-loop
}


#' @S3method print analyzeFeatSelResult
print.analyzeFeatSelResult = function(x, ...) {
  switch(class(x$control)[1L],
         FeatSelControlSequential = printAnalyzeFeatSelResultSeq(x, ...),
         FeatSelControlGA = printAnalyzeFeatSelResultGA(x, ...))
}
