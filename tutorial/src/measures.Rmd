# Implemented Performance Measures

The following tables show the performance measures available for the different types of
learning problems as well as general performance measures in alphabetical order.

Column **Minimize** indicates if the measure is minimized during, e.g., tuning or
feature selection.
**Best** and **Worst** show the best and worst values the performance measure can attain.

**PredType** shows the supported type of prediction.
Columns **Prediction**, **Model**, and **Task** indicate if the measure requires the [&Prediction],
the [WrappedModel](&makeWrappedModel) and/or the [&Task].

**Aggregation** shows the default aggregation method.

For *classification*, column **MultiClass** indicates if a measure is suitable for
multi-class problems. If not, the measure can only be used for binary classification problems.


```{r include=FALSE}
linkFct = function(x) {
  collapse(sprintf("[%1$s](http://www.rdocumentation.org/packages/mlr/functions/measures)", x), sep = "<br />")
}

getTab = function(type) {
  m = list(featperc = featperc, timeboth = timeboth, timepredict = timepredict, timetrain = timetrain)

  if (type == "general") {
    meas = m
  } else {
    meas = listMeasures(type, create = TRUE)
    ord = order(names(meas))
    meas = meas[ord]
    keep = setdiff(names(meas), names(m))
    meas = meas[keep]
  }

  cols = c("Measure", "Minimize", "Best", "Worst", "MultiClass", "PredType", "Prediction", "Model", "Task", "Aggregation")
  df = makeDataFrame(nrow = length(meas), ncol = length(cols),
    col.types = c("character", "logical", "numeric", "numeric", "logical", "character", "logical", "logical", "logical", "character"))
  names(df) = cols

  for (i in seq_along(meas)) {
    mea = meas[[i]]
    df[i, 1] = paste0(linkFct(mea$id), " - ", mea$note)
    df[i, 2] = mea$minimize
    df[i, 3] = mea$best
    df[i, 4] = mea$worst
    df[i, 5] = "classif.multi" %in% mea$properties
    df[i, 6] = sort(collapse(mea$allowed.pred.types, sep = "<br />"))
    df[i, 7] = mea$req.pred
    df[i, 8] = mea$req.model
    df[i, 9] = mea$req.task
    df[i, 10] = mea$aggr$id
  }

  just = c("left", "center", "right", "right", "center", "left", "center", "center", "center", "left")

  if (type != "classif") {
    df$MultiClass = NULL
    just = just[-5]
  }

  logicals = vlapply(df, is.logical)
  df[logicals] = lapply(df[logicals], function(x) ifelse(x, "X", ""))
  pandoc.table(df, style = "rmarkdown", split.tables = Inf, split.cells = Inf,
    justify = just)
}
```

<style type="text/css">
<!--
.col-md-9 th {
padding: 0.5em;
}
.col-md-9 td {
border: solid 1px #ccc;
padding: 0.5em;
vertical-align: top;
}
-->
</style>

### Classification
```{r echo=FALSE,results="asis"}
getTab("classif")
```

### Regression
```{r echo=FALSE,results="asis"}
getTab("regr")
```

### Survival analysis
```{r echo=FALSE,results="asis"}
getTab("surv")
```

### Cluster analysis
```{r echo=FALSE,results="asis"}
getTab("cluster")
```

### Cost-sensitive classification
```{r echo=FALSE,results="asis"}
getTab("costsens")
```

### General performance measures
```{r echo=FALSE,results="asis"}
getTab("general")
```
