Learning Tasks
==============

Learning tasks are the basic elements of the package to encapsulate the
data set and all relevant information regarding the purpose of the
task, e.g, the target variable.

Currently these subclasses of a \man[SupervisedTask] exist: \man2[ClassifTask][SupervisedTask] for classification and \man2[RegrTask][SupervisedTask] for regression problems.
**mlr** also offers survival analysis (\man2[SurvTask][SupervisedTask]) and cost-sensitive learning (\man2[SurvTask][CostSensTask]).
A classification task is created by using \man2[makeClassifTask][SupervisedTask],
\man2[makeRegrTask][SupervisedTask] is used for regression task.

In the following example, we define a classification task for the data
set ``BreastCancer`` (from the package mlbench) and exclude the ID
variable from all further model fitting and evaluation.

```{r}
library("mlr")
library("mlbench")
data(BreastCancer)

df = BreastCancer
df$Id = NULL
classif.task = makeClassifTask(id = "BreastCancer", data = df, target = "Class")
classif.task
```

As we can see, the task records basic information about the data set,
e.g., the types of the features, the number of observations, whether
missing values are present, the number of observations per class and so on.


In many of the following regression examples we will use the ``BostonHousing`` data set:

```{r}
data(BostonHousing)
regr.task = makeRegrTask(id = "BostonHousing", data = BostonHousing, target = "medv")
regr.task
```

Further information
-------------------

Let's have another look at the classification example.

As this is a binary problem, we see that a positive class is selected
by default. This will generally be auto-selected, but you might
want to do this manually for your application. It mainly concerns ROC analysis, where in order
to talk about something like a true positive rate, we need to know which of the two classes is the positive
one.

```{r}
classif.task = makeClassifTask(id = "BreastCancer", data = df, target = "Class",
  positive = "malignant")
```

There are also some convenient methods to access properties and parts of the task.
The most important ones are listed in \man[SupervisedTask].

Here are some examples.


```{r}
# get the names of the input variables:
getTaskFeatureNames(classif.task)

# get values of the target variable for all observations:
head(getTaskTargets(classif.task))
head(getTaskTargets(regr.task))

# accessing the data set:
str(getTaskData(classif.task))
```

Note the many options \man[getTaskData] provides to convert the data set into a covenient format.
This is especially handy when you integrate a learner from another package into mlr.

If you are more technically inclined, you could also directly access
the information stored in the slot called `task$task.desc`,
which stands for "description" and is of class \man[TaskDesc].

```{r}
str(classif.task$task.desc)
```

The \man[SupervisedTask] help page also lists several other arguments
to describe further details of the problem.

E.g., we could include a blocking factor into the task.
This would tell the task that some observations "belong together", so they are either put all
in the training or the test set during a resampling iteration.
Or you could weight observations according to their importance.

